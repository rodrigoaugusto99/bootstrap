---
alwaysApply: true
---

# MDC — Padrão de Uso de Schemas

# Objetivo

Este documento define o padrão oficial de uso de Schemas no projeto.
Schemas existem para organizar dados quando funções começam a receber
muitos parâmetros ou quando há troca estruturada de dados entre camadas,
como em chamadas de API ou operações de persistência.

O uso de schemas evita funções com múltiplos parâmetros primitivos,
melhora legibilidade, facilita manutenção e serve como contrato claro
entre camadas e serviços.

Esse padrão deve ser seguido tanto por desenvolvedores humanos
quanto por inteligências artificiais que atuem no projeto.

# Localização dos Schemas

Todo schema deve ser criado dentro da pasta:

lib/schemas/

Cada arquivo representa um schema específico de uso,
normalmente associado a um fluxo, ação ou contrato de dados.

Exemplos de arquivos:

lib/schemas/user_registration_schema.dart  
lib/schemas/get_coordinates_from_address_response.dart

# Quando Criar um Schema

Um schema deve ser criado sempre que:

Uma função começa a receber muitos parâmetros  
Os parâmetros fazem parte de um mesmo contexto ou fluxo  
Os dados representam um contrato entre camadas  
Há troca de dados com APIs externas  
Há necessidade de converter dados para Map<String, dynamic>

Schemas substituem múltiplos parâmetros posicionais
por um único objeto semântico.

# Exemplo de Uso em Fluxo de Registro

No final de um fluxo de registro,
ao invés de chamar uma função com vários parâmetros,
deve-se instanciar um schema.

```dart
final userRegistrationSchema = UserRegistrationSchema(
  name: fullNameController.text,
);

await _userService.updateUserRegistration(userRegistrationSchema);
```

Nesse cenário, o schema representa o estado final do fluxo
e encapsula todos os dados necessários para a operação.

# Estrutura Obrigatória de um Schema

Todo schema deve conter:

Construtor explícito
Atributos finais
Método toMap
Factory fromMap

Schemas não contêm lógica de negócio.
Eles apenas representam dados.

# Exemplo de Schema de Registro de Usuário

```dart
class UserRegistrationSchema {
  UserRegistrationSchema({required this.name});

  final String name;

  Map<String, dynamic> toMap() {
    return {
      'name': name,
    };
  }

  factory UserRegistrationSchema.fromMap(Map<String, dynamic> map) {
    return UserRegistrationSchema(
      name: map['name'],
    );
  }
}

```

# Uso do Schema Dentro do Service

O Service recebe o schema como argumento
e utiliza o método toMap para repassar os dados
para a camada de Firestore ou API.

```dart
Future<void> updateUserRegistration(
  UserRegistrationSchema userRegistrationSchema,
) async {
  try {
    await firestore.updateUser(
      map: userRegistrationSchema.toMap(),
      userId: user.value!.id,
    );
  } catch (e) {
    rethrow;
  }
}

```

Nesse padrão, a ViewModel não conhece
a estrutura do banco nem os nomes dos campos.

# Schemas em Chamadas de API

Schemas também devem ser usados em integrações com APIs.
Nesse caso, normalmente existem dois tipos de schema:

Schema de request
Schema de response

Esses schemas representam contratos explícitos
entre o app e a API.

## Exemplo de Função que Chama API

```dart
Future<GetCoordinatesFromAddressResponse> getCoordinatesFromAddress(
  AddressModel address,
) async {
  final response = await _apiService.request(
    method: HttpMethod.POST,
    url: '$apiUrl/user/geocoding',
    body: address.toMap(),
  );

  return GetCoordinatesFromAddressResponse(
    latitude: response['latitude'],
    longitude: response['longitude'],
  );
}

```

Nesse exemplo:

O request utiliza um modelo específico para envio
O response é representado por um schema dedicado

O schema de response não é um model de domínio,
mas sim um contrato de dados retornado pela API.

# Exemplo de Schema de Response de API

```dart
class GetCoordinatesFromAddressResponse {
  GetCoordinatesFromAddressResponse({
    required this.latitude,
    required this.longitude,
  });

  final double latitude;
  final double longitude;

  Map<String, dynamic> toMap() {
    return <String, dynamic>{
      'latitude': latitude,
      'longitude': longitude,
    };
  }

  factory GetCoordinatesFromAddressResponse.fromMap(
    Map<String, dynamic> map,
  ) {
    return GetCoordinatesFromAddressResponse(
      latitude: map['latitude'] as double,
      longitude: map['longitude'] as double,
    );
  }
}

```

# Diferença Entre Schema e Model

Schemas representam dados temporários ou contratuais.
Eles são usados para:

Fluxos
Requests
Responses
Atualizações parciais

Models representam entidades do domínio
e refletem dados persistidos ou centrais do sistema.

Schemas não substituem models de domínio.

# Diretriz Final

Sempre que uma função começar a crescer em parâmetros,
crie um schema.

Sempre que houver troca estruturada de dados entre camadas,
utilize schemas.

Sempre que integrar com APIs,
defina schemas explícitos de request e response.

Schemas devem viver em lib/schemas
e conter obrigatoriamente toMap e fromMap.

Esse padrão garante clareza,
desacoplamento
e facilidade de manutenção ao longo do tempo.
