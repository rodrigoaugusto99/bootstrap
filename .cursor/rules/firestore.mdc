---
alwaysApply: true
---

# MDC — Padrão de Uso do Firestore

# Objetivo

Este documento define o padrão oficial de uso do Firebase Firestore no projeto.
Ele existe para padronizar organização, responsabilidades de camada e fluxo de dados,
além de servir como referência direta para inteligências artificiais seguirem
exatamente o mesmo estilo de implementação utilizado pelo desenvolvedor.

# Organização de Pastas

Toda lógica puramente relacionada ao Firestore deve ficar concentrada na pasta:

lib/firestore/

Arquivos dentro dessa pasta representam apenas acesso ao banco de dados,
como por exemplo:

lib/firestore/user.dart  
lib/firestore/chat.dart  
lib/firestore/message.dart

# Responsabilidade da Camada Firestore

A camada firestore é considerada infraestrutura.
Ela é responsável apenas por acessar o banco e retornar dados já convertidos em models.

Essa camada pode:
Acessar coleções e documentos  
Executar operações de get, set, update e snapshots  
Converter Map<String, dynamic> em models

Essa camada não pode:
Conter regras de negócio  
Conter lógica de UI  
Acessar BuildContext  
Acessar ValueNotifier, ChangeNotifier ou ViewModels

# Fluxo Arquitetural Obrigatório

O fluxo de dados deve sempre respeitar a seguinte ordem:

Firestore → Service → ViewModel

Firestore acessa o banco e retorna dados crus já convertidos em models.
Service orquestra chamadas e define quais campos serão criados ou atualizados.
ViewModel gerencia estado e interação com a UI.

Em nenhuma hipótese a ViewModel deve acessar Firestore diretamente.

# Exemplo de Implementação Firestore

Arquivo: lib/firestore/user.dart

# Leitura com escuta em tempo real

Esse tipo de método só deve ser usado em casos específicos.
Normalmente quando o dado precisa permanecer sincronizado em tempo real,
como acontece com dados globais ou singletons, por exemplo o usuário logado.

Esse método retorna um StreamSubscription para permitir o cancelamento posterior.

```dart
Future<StreamSubscription> getAndListenUserById({
  required Function(UserModel) onNewSnapshot,
  required String userId,
}) async {
  try {
    final CollectionReference usersCollection =
        FirebaseFirestore.instance.collection('users');

    final query = usersCollection.doc(userId);

    final newSnapshot = await query.get();
    final updatedUser = UserModel.fromMap(
      newSnapshot.data() as Map<String, dynamic>,
      newSnapshot.id,
    );

    await onNewSnapshot(updatedUser);

    return query.snapshots().skip(1).listen((newSnapshot) async {
      final updatedUser = UserModel.fromMap(
        newSnapshot.data() as Map<String, dynamic>,
        newSnapshot.id,
      );
      await onNewSnapshot(updatedUser);
    });
  } catch (error) {
    rethrow;
  }
}

```

Esse padrão é exceção e não deve ser usado como default.
A maior parte das leituras não deve utilizar streams.

# Leitura Simples de Documento

Na maioria dos casos o acesso ao Firestore deve ser feito com leitura simples,
sem escutar alterações em tempo real.

```dart
Future<UserModel?> getUserById(String userId) async {
  try {
    final doc = await FirebaseFirestore.instance
        .collection('users')
        .doc(userId)
        .get();

    if (!doc.exists) return null;

    return UserModel.fromMap(
      doc.data() as Map<String, dynamic>,
      doc.id,
    );
  } catch (error) {
    rethrow;
  }
}

```

Esse método retorna apenas o model necessário,
sem expor streams ou subscriptions.

# Criação de Documento no Firestore

A criação de documentos deve acontecer exclusivamente na camada firestore,
sem validações de regra de negócio.

```dart
Future<void> createUser({
  required Map<String, dynamic> userMap,
  required String userId,
}) async {
  try {
    final docRef =
        FirebaseFirestore.instance.collection('users').doc(userId);

    final docSnapshot = await docRef.get();
    if (docSnapshot.exists) {
      _log.i('User already exists: $userId');
      return;
    }

    await docRef.set(userMap);
    _log.i('User created with success: $userId, $userMap');
  } catch (error) {
    rethrow;
  }
}

```

# Atualização Parcial de Documento

Atualizações devem sempre ser feitas de forma parcial,
recebendo apenas um Map<String, dynamic> com os campos a serem alterados.

```dart
Future<void> updateUser({
  required Map<String, dynamic> map,
  required String userId,
}) async {
  try {
    await FirebaseFirestore.instance
        .collection('users')
        .doc(userId)
        .update(map);
  } catch (error) {
    rethrow;
  }
}

```

# Papel dos Services

Services funcionam como ponte entre Firestore e ViewModels.
Eles existem para orquestrar chamadas, centralizar regras de escrita
e proteger a ViewModel de mudanças estruturais no banco de dados.

A ViewModel nunca deve conhecer nomes de campos do Firestore.
Essa responsabilidade é exclusiva dos Services.

# Exemplo de Service de Usuário

Nesse exemplo, o usuário é tratado como singleton
e permanece sincronizado em tempo real.

```dart
ValueNotifier<UserModel?> user = ValueNotifier(null);
StreamSubscription? _userSubscription;

Future<void> setUser(String uid) async {
  try {
    _userSubscription = await firestore.getAndListenUserById(
      onNewSnapshot: (user) {
        this.user.value = user;
      },
      userId: uid,
    );
  } catch (e) {
    rethrow;
  }
}

```

# Criação de Usuário via Service

Mesmo podendo chamar diretamente o Firestore,
a criação passa pelo Service para manter o padrão arquitetural.

```dart
Future<void> createUserProfile() async {
  try {
    if (currUser == null) {
      _log.e('currUser is null');
      return;
    }

    String uid = currUser!.uid;
    String newName = (currUser!.displayName)?.trim() ?? '';

    final userProfile = {
      'name': newName,
      'email': currUser!.email,
      'emailUpperCase': currUser!.email?.toUpperCase(),
      'nameUpperCase': newName.toUpperCase(),
      'createdAt': FieldValue.serverTimestamp(),
    };

    await firestore.createUser(
      userMap: userProfile,
      userId: uid,
    );
  } catch (e) {
    _log.e('Erro ao criar perfil do usuário: $e');
    throw AppError(message: 'Erro ao cadastrar usuário');
  }
}

```

# Atualização de Campos Específicos via Service

Os Services são responsáveis por definir quais campos do banco serão alterados.
Isso evita que mudanças no Firestore impactem diretamente as ViewModels.

```dart
Future<void> updateUserSex(SexEnum sex) async {
  try {
    await firestore.updateUser(
      map: {
        'sex': sex.name,
      },
      userId: user.value!.id,
    );
  } catch (e) {
    rethrow;
  }
}

```

Se um campo mudar de nome no banco,
a alteração deve ocorrer apenas no Service,
sem necessidade de modificar ViewModels.

# Diretriz Final

Sempre que trabalhar com Firestore neste projeto:

Use a pasta lib/firestore para acesso ao banco
Respeite o fluxo Firestore → Service → ViewModel
Não exponha Map<String, dynamic> para ViewModels
Utilize streams apenas quando houver real necessidade
Centralize nomes de campos e decisões de escrita nos Services

Esse padrão deve ser seguido tanto por desenvolvedores humanos
quanto por inteligências artificiais que atuem no projeto.
